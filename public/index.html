<!DOCTYPE html>
<html>
<head>
    <title>Aquarium Wednesday</title>
    <style>
        body {
            background: #b3e0ff;
        }

        canvas {
            background: #66ccff;
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    <div id="fishControls" style="text-align:center; margin-top: 16px;">
        <input id="fishNameInput" type="text" placeholder="Fish name" maxlength="16">
        <input id="fishColorInput" type="color" value="#ff9900">
        <button id="addFishBtn">Add My Fish</button>
    </div>

    <canvas id="aquarium" width="900" height="600"></canvas>
    <script src="/socket.io/socket.io.js"></script>
    <script>
        const canvas = document.getElementById('aquarium');
        const ctx = canvas.getContext('2d');
        const socket = io();
        console.log('Socket.IO client loaded:', socket);

        function getRandomColor() {
            // Returns a random hex color string
            return '#' + Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0');
        }
        document.getElementById('fishColorInput').value = getRandomColor();



        let fishArray = [];
        let bubbles = [];

        function drawSand() {
            ctx.fillStyle = "#f7d488";
            ctx.beginPath();
            ctx.moveTo(0, canvas.height - 30);
            ctx.quadraticCurveTo(canvas.width * 0.25, canvas.height - 10, canvas.width * 0.5, canvas.height - 20);
            ctx.quadraticCurveTo(canvas.width * 0.75, canvas.height - 30, canvas.width, canvas.height - 10);
            ctx.lineTo(canvas.width, canvas.height);
            ctx.lineTo(0, canvas.height);
            ctx.closePath();
            ctx.fill();
        }
        function drawFish(fish) {
            const scale = fish.size || 1;
            ctx.save();
            ctx.translate(fish.x, fish.y);

            let flip = (fish.dx < 0) ? -1 : 1;
            ctx.scale(flip * scale, scale);

            // Draw the body
            ctx.beginPath();
            ctx.ellipse(0, 0, 30, 15, 0, 0, Math.PI * 2);
            ctx.fillStyle = fish.color;
            ctx.fill();

            // Draw single wiggling side fin
            const finOffsetX = -4; // negative = back
            const finOffsetY = 4;  // positive = down

            let finWiggle = Math.sin((fish.tailWigglePhase || 0) + 1.0) * 4;

            ctx.beginPath();
            ctx.moveTo(8 + finOffsetX, 0 + finOffsetY);
            ctx.quadraticCurveTo(
                16 + finOffsetX, -6 + finWiggle + finOffsetY,
                20 + finOffsetX, 0 + finOffsetY
            );
            ctx.quadraticCurveTo(
                16 + finOffsetX, 6 + finWiggle + finOffsetY,
                8 + finOffsetX, 0 + finOffsetY
            );
            ctx.closePath();
            ctx.fillStyle = fish.finColor || "#ffe066"; // fallback if missing
            ctx.globalAlpha = 0.7;
            ctx.fill();
            ctx.globalAlpha = 1.0;


            // Draw the tail with wiggle
            let tailWiggle = Math.sin(fish.tailWigglePhase || 0) * 10;
            ctx.beginPath();
            ctx.moveTo(-30, 0);
            ctx.lineTo(-45, -10 + tailWiggle);
            ctx.lineTo(-45, 10 + tailWiggle);
            ctx.closePath();
            ctx.fillStyle = fish.tailColor || "#d94f00";
            ctx.fill();

            ctx.restore();

            // Draw name if present
            if (fish.name && fish.name.trim().length > 0) {
                ctx.font = `${14 * scale}px Arial`;
                ctx.fillStyle = "#222";
                ctx.textAlign = "center";
                ctx.fillText(fish.name, fish.x, fish.y - 25 * scale);
            }
        }


        function drawBubble(bubble) {
            ctx.save();
            ctx.globalAlpha = 0.5;
            ctx.beginPath();
            ctx.arc(bubble.x, bubble.y, bubble.radius, 0, Math.PI * 2);
            ctx.fillStyle = "#ffffff";
            ctx.fill();
            ctx.globalAlpha = 1.0;
            ctx.restore();
        }

        function drawCrab(crab) {
            if (!crab) return;
            ctx.save();
            ctx.translate(crab.x, crab.y);

            // Body
            ctx.beginPath();
            ctx.arc(0, 0, 12, Math.PI, 2 * Math.PI);
            ctx.fillStyle = "#d2691e";
            ctx.fill();

            // Animated Legs (3 per side)
            ctx.strokeStyle = "#a0522d";
            ctx.lineWidth = 2;
            const legLength = 12;
            const steps = 1; // Only two positions: -1 and 1

            for (let i = -1; i <= 1; i++) {
                let phase = (crab.stepPhase || 0) + i * 0.6;
                let raw = Math.sin(phase);
                let quantized = Math.sign(raw); // Will be -1, 0, or 1 (but mostly -1 or 1)
                let wiggle = quantized * 0.25; // amplitude

                let baseAngle = Math.PI / 3 + i * 0.2;
                let angleLeft = baseAngle - wiggle;
                let angleRight = Math.PI - baseAngle + wiggle;

                // Left leg
                ctx.beginPath();
                ctx.moveTo(-8, 4 + i * 3);
                ctx.lineTo(
                    -8 + legLength * Math.cos(angleLeft),
                    4 + i * 3 + legLength * Math.sin(angleLeft)
                );
                ctx.stroke();

                // Right leg
                ctx.beginPath();
                ctx.moveTo(8, 4 + i * 3);
                ctx.lineTo(
                    8 + legLength * Math.cos(angleRight),
                    4 + i * 3 + legLength * Math.sin(angleRight)
                );
                ctx.stroke();
            }
            // Claws (arms with pincers)
            function drawClawArm(side) {
                // side: -1 for left, 1 for right
                // Arm base coordinates
                const armBaseX = 10 * side;
                const armBaseY = -2;

                // Arm direction/angle
                const armAngle = side === -1 ? -Math.PI / 3 : -2 * Math.PI / 3;
                const armLength = 10;

                // Arm tip coordinates
                const armTipX = armBaseX + armLength * Math.cos(armAngle);
                const armTipY = armBaseY + armLength * Math.sin(armAngle);

                // Draw arm
                ctx.beginPath();
                ctx.moveTo(armBaseX, armBaseY);
                ctx.lineTo(armTipX, armTipY);
                ctx.stroke();

                // Draw pincer (two small lines forming a "V" at the tip)
                const clawSpread = Math.PI / 6; // 30 degrees
                const clawLength = 6;

                // First pincer segment
                ctx.beginPath();
                ctx.moveTo(armTipX, armTipY);
                ctx.lineTo(
                    armTipX + clawLength * Math.cos(armAngle + clawSpread),
                    armTipY + clawLength * Math.sin(armAngle + clawSpread)
                );
                ctx.stroke();

                // Second pincer segment
                ctx.beginPath();
                ctx.moveTo(armTipX, armTipY);
                ctx.lineTo(
                    armTipX + clawLength * Math.cos(armAngle - clawSpread),
                    armTipY + clawLength * Math.sin(armAngle - clawSpread)
                );
                ctx.stroke();
            }
            // Call this for both sides in your drawCrab function, after drawing the legs:
            ctx.strokeStyle = "#a0522d";
            ctx.lineWidth = 2;
            drawClawArm(-1); // left arm
            drawClawArm(1);  // right arm


            // Claws
            ctx.beginPath();
            ctx.moveTo(-10, -2);
            ctx.lineTo(-16, -8);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(10, -2);
            ctx.lineTo(16, -8);
            ctx.stroke();

            // Eyes
            ctx.beginPath();
            ctx.arc(-4, -10, 2, 0, 2 * Math.PI);
            ctx.arc(4, -10, 2, 0, 2 * Math.PI);
            ctx.fillStyle = "#fff";
            ctx.fill();
            ctx.beginPath();
            ctx.arc(-4, -10, 1, 0, 2 * Math.PI);
            ctx.arc(4, -10, 1, 0, 2 * Math.PI);
            ctx.fillStyle = "#222";
            ctx.fill();

            ctx.restore();
        }


        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawSand();
            drawCrab(crab);

            // Draw bubbles
            for (let bubble of bubbles) {
                drawBubble(bubble);
            }
            // Draw fish
            for (let fish of fishArray) {
                drawFish(fish);
            }
            requestAnimationFrame(draw);
        }

        let crab = null;
        socket.on('aquariumState', (state) => {
            fishArray = state.fishArray;
            bubbles = state.bubbles;
            crab = state.crab || null;
        });



        document.getElementById('addFishBtn').onclick = function () {
            const nameInput = document.getElementById('fishNameInput');
            const colorInput = document.getElementById('fishColorInput');
            const name = nameInput.value.trim(); // No fallback!
            const color = colorInput.value || "#ff9900";
            socket.emit('addFish', { name, color });

            // Set the color picker to a new random color for the next fish
            colorInput.value = getRandomColor();

            // Clear the name input box
            nameInput.value = '';
        };


        draw();


        canvas.addEventListener('click', function (event) {
            // Get mouse position relative to the canvas
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;

            // Find the first fish under the mouse
            for (let i = 0; i < fishArray.length; i++) {
                const fish = fishArray[i];
                // Fish hitbox: ellipse of rx=30, ry=15
                const dx = mouseX - fish.x;
                const dy = mouseY - fish.y;
                if ((dx * dx) / (30 * 30) + (dy * dy) / (15 * 15) <= 1) {
                    // Found a fish! Tell the server to reverse its direction
                    socket.emit('reverseFish', i);
                    break;
                }
            }
        });
    </script>
</body>
</html>
