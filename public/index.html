<!DOCTYPE html>
<html>
<head>
    <title>Aquarium Wednesday</title>
    <style>
        body {
            background: #b3e0ff;
        }

        canvas {
            background: #66ccff;
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    <div id="fishControls" style="text-align:center; margin-top: 16px;">
        <input id="fishNameInput" type="text" placeholder="Fish name" maxlength="16">
        <input id="fishColorInput" type="color" value="#ff9900">
        <button id="addFishBtn">Add My Fish</button>
    </div>

    <canvas id="aquarium" width="900" height="600"></canvas>
    <script src="/socket.io/socket.io.js"></script>
    <script>
        const canvas = document.getElementById('aquarium');
        const ctx = canvas.getContext('2d');
        const socket = io();
        console.log('Socket.IO client loaded:', socket);

        let animationStart = Date.now();


        function getRandomColor() {
            // Returns a random hex color string
            return '#' + Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0');
        }
        document.getElementById('fishColorInput').value = getRandomColor();

        // Simple deterministic pseudo-random number generator
        function seededRandom(seed) {
            let value = seed % 2147483647;
            return function () {
                value = (value * 48271) % 2147483647;
                return (value - 1) / 2147483646; // Returns float between 0 and 1
            };
        }


        let fishArray = [];
        let bubbles = [];

        function drawSand() {
            ctx.fillStyle = "#f7d488";
            ctx.beginPath();
            ctx.moveTo(0, canvas.height - 30);
            ctx.quadraticCurveTo(canvas.width * 0.25, canvas.height - 10, canvas.width * 0.5, canvas.height - 20);
            ctx.quadraticCurveTo(canvas.width * 0.75, canvas.height - 30, canvas.width, canvas.height - 10);
            ctx.lineTo(canvas.width, canvas.height);
            ctx.lineTo(0, canvas.height);
            ctx.closePath();
            ctx.fill();
        }

        function drawSeaweed() {
            const seaweedCount = 7;
            const margin = 40; // Don't put seaweed at the very edge
            const minDist = 30; // Minimum distance between tufts

            // Use a fixed seed for identical placement on all clients
            const rand = seededRandom(12345);

            // Generate random but deterministic X positions
            let positions = [];
            while (positions.length < seaweedCount) {
                let x = margin + rand() * (canvas.width - 2 * margin);
                // Ensure minimum distance from previous tufts
                if (positions.every(px => Math.abs(px - x) > minDist)) {
                    positions.push(x);
                }
            }
            positions.sort((a, b) => a - b); // optional: sort for left-to-right order

            // Animate sway based on time since page load
            let elapsed = (Date.now() - animationStart) / 1000; // seconds

            for (let i = 0; i < seaweedCount; i++) {
                let baseX = positions[i];
                let baseY = canvas.height - 30; // Just above the sand
                let height = 60 + Math.sin(elapsed / 0.9 + i) * 10; // Animate sway

                ctx.save();
                ctx.beginPath();
                ctx.moveTo(baseX, baseY);

                for (let seg = 0; seg < 3; seg++) {
                    let segY = baseY - (height * (seg + 1) / 3);
                    let sway = Math.sin(elapsed + i + seg) * 8 * (1 - seg / 3);
                    ctx.quadraticCurveTo(
                        baseX + sway,
                        baseY - height * (seg + 0.5) / 3,
                        baseX,
                        segY
                    );
                }

                ctx.strokeStyle = "#228B22";
                ctx.lineWidth = 4;
                ctx.shadowColor = "#145214";
                ctx.shadowBlur = 5;
                ctx.stroke();
                ctx.restore();
            }
        }




        function drawFish(fish) {
            const scale = fish.size || 1;
            ctx.save();
            ctx.translate(fish.x, fish.y);

            let flip = (fish.dx < 0) ? -1 : 1;
            ctx.scale(flip * scale, scale);

            // Draw the body
            ctx.beginPath();
            ctx.ellipse(0, 0, 30, 15, 0, 0, Math.PI * 2);
            ctx.fillStyle = fish.color;
            ctx.fill();

            // Draw single wiggling side fin
            const finOffsetX = -4; // negative = back
            const finOffsetY = 4;  // positive = down

            let finWiggle = Math.sin((fish.tailWigglePhase || 0) + 1.0) * 4;

            ctx.beginPath();
            ctx.moveTo(8 + finOffsetX, 0 + finOffsetY);
            ctx.quadraticCurveTo(
                16 + finOffsetX, -6 + finWiggle + finOffsetY,
                20 + finOffsetX, 0 + finOffsetY
            );
            ctx.quadraticCurveTo(
                16 + finOffsetX, 6 + finWiggle + finOffsetY,
                8 + finOffsetX, 0 + finOffsetY
            );
            ctx.closePath();
            ctx.fillStyle = fish.finColor || "#ffe066"; // fallback if missing
            ctx.globalAlpha = 0.7;
            ctx.fill();
            ctx.globalAlpha = 1.0;


            // Draw the tail with wiggle
            let tailWiggle = Math.sin(fish.tailWigglePhase || 0) * 10;
            ctx.beginPath();
            ctx.moveTo(-30, 0);
            ctx.lineTo(-45, -10 + tailWiggle);
            ctx.lineTo(-45, 10 + tailWiggle);
            ctx.closePath();
            ctx.fillStyle = fish.tailColor || "#d94f00";
            ctx.fill();

            ctx.restore();

            // Draw name if present
            if (fish.name && fish.name.trim().length > 0) {
                ctx.font = `${14 * scale}px Arial`;
                ctx.fillStyle = "#222";
                ctx.textAlign = "center";
                ctx.fillText(fish.name, fish.x, fish.y - 25 * scale);
            }
        }


        function drawBubble(bubble) {
            ctx.save();
            ctx.globalAlpha = 0.5;
            ctx.beginPath();
            ctx.arc(bubble.x, bubble.y, bubble.radius, 0, Math.PI * 2);
            ctx.fillStyle = "#ffffff";
            ctx.fill();
            ctx.globalAlpha = 1.0;
            ctx.restore();
        }

        function drawCrab(crab) {
            if (!crab) return;
            ctx.save();
            ctx.translate(crab.x, crab.y);

            // Body
            ctx.beginPath();
            ctx.arc(0, 0, 12, Math.PI, 2 * Math.PI);
            ctx.fillStyle = "#d2691e";
            ctx.fill();

            // Animated Legs (3 per side)
            ctx.strokeStyle = "#a0522d";
            ctx.lineWidth = 2;
            const legLength = 12;

            for (let i = -1; i <= 1; i++) {
                let phase = (crab.stepPhase || 0) + i * 0.6;
                let raw = Math.sin(phase);
                let quantized = Math.sign(raw);
                let wiggle = quantized * 0.25;

                let baseAngle = Math.PI / 3 + i * 0.2;
                let angleLeft = baseAngle - wiggle;
                let angleRight = Math.PI - baseAngle + wiggle;

                // Left leg
                ctx.beginPath();
                ctx.moveTo(-8, 4 + i * 3);
                ctx.lineTo(
                    -8 + legLength * Math.cos(angleLeft),
                    4 + i * 3 + legLength * Math.sin(angleLeft)
                );
                ctx.stroke();

                // Right leg
                ctx.beginPath();
                ctx.moveTo(8, 4 + i * 3);
                ctx.lineTo(
                    8 + legLength * Math.cos(angleRight),
                    4 + i * 3 + legLength * Math.sin(angleRight)
                );
                ctx.stroke();
            }

            // Claws (arms with pincers)
            function drawClaw(side) {
                // side: -1 for left, 1 for right
                var baseX = 13 * side;  // position to the left/right of body
                var baseY = -5;         // a little above crab center
                var clawWidth = 8;      // smaller width
                var clawHeight = 6;     // smaller height
                var clawAngle = side * Math.PI / 4; // rotate outward 45 degrees

                ctx.save();
                ctx.translate(baseX, baseY);
                ctx.rotate(clawAngle);

                // Draw a Pac-Man style claw (ellipse with a wedge missing)
                ctx.beginPath();
                var startAngle = -Math.PI / 4;
                var endAngle = 2 * Math.PI - Math.PI / 4;
                var mouthOpen = Math.PI / 3; // size of the "mouth" wedge

                ctx.ellipse(
                    0, 0,
                    clawWidth, clawHeight,
                    0,
                    startAngle + mouthOpen / 2,
                    endAngle - mouthOpen / 2,
                    false
                );
                ctx.lineTo(0, 0); // close the mouth
                ctx.closePath();

                ctx.fillStyle = "#d2691e";
                ctx.strokeStyle = "#a0522d";
                ctx.lineWidth = 2;
                ctx.fill();
                ctx.stroke();

                ctx.restore();
            }



            drawClaw(-1); // left
            drawClaw(1);  // right

            // Eyes
            ctx.beginPath();
            ctx.arc(-4, -10, 2, 0, 2 * Math.PI);
            ctx.arc(4, -10, 2, 0, 2 * Math.PI);
            ctx.fillStyle = "#fff";
            ctx.fill();
            ctx.beginPath();
            ctx.arc(-4, -10, 1, 0, 2 * Math.PI);
            ctx.arc(4, -10, 1, 0, 2 * Math.PI);
            ctx.fillStyle = "#222";
            ctx.fill();

            ctx.restore();
        }



        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawSeaweed();  // <-- Add this line!
            drawSand();
            drawCrab(crab);

            // Draw bubbles
            for (let bubble of bubbles) {
                drawBubble(bubble);
            }
            // Draw fish
            for (let fish of fishArray) {
                drawFish(fish);
            }
            requestAnimationFrame(draw);
        }


        let crab = null;
        socket.on('aquariumState', (state) => {
            fishArray = state.fishArray;
            bubbles = state.bubbles;
            crab = state.crab || null;
        });



        document.getElementById('addFishBtn').onclick = function () {
            const nameInput = document.getElementById('fishNameInput');
            const colorInput = document.getElementById('fishColorInput');
            const name = nameInput.value.trim(); // No fallback!
            const color = colorInput.value || "#ff9900";
            socket.emit('addFish', { name, color });

            // Set the color picker to a new random color for the next fish
            colorInput.value = getRandomColor();

            // Clear the name input box
            nameInput.value = '';
        };


        draw();


        canvas.addEventListener('click', function (event) {
            // Get mouse position relative to the canvas
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;

            // Find the first fish under the mouse
            for (let i = 0; i < fishArray.length; i++) {
                const fish = fishArray[i];
                // Fish hitbox: ellipse of rx=30, ry=15
                const dx = mouseX - fish.x;
                const dy = mouseY - fish.y;
                if ((dx * dx) / (30 * 30) + (dy * dy) / (15 * 15) <= 1) {
                    // Found a fish! Tell the server to reverse its direction
                    socket.emit('reverseFish', i);
                    break;
                }
            }
        });
    </script>
</body>
</html>
